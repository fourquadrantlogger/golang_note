
# 垃圾收集器（GC）

  GC与增变线程同时运行，类型准确（又精确），允许多个
 GC线程并行运行。这是一个并发的标记和扫描，使用写屏障。它是
非代和压缩分配使用每个P分配的大小分离来完成
在最常的情况下，尽量减少碎片，同时消除锁定。

算法分成几个步骤。
这是对正在使用的算法的高级描述。有关GC的一个好的概述
开始的地方是Richard Jones的gchandbook.org。

算法的智力遗产包括Dijkstra的即时算法，请参阅
 Edsger W. Dijkstra，Leslie Lamport，A. J. Martin，C. S. Scholten和E. F. M. Steffens。 1978年。
即时垃圾收集：合作练习。 COMMUN。 ACM 21,11（1978年11月），
 966-975。
对于期刊质量的证明，这些步骤是完整的，正确的，并终止见
 Hudson，R.和Moss，J.E.在不停止世界的情况下复制垃圾收集。
并发和计算：实践和经验15（3-5），2003。

 GC执行扫描终止。

 一个。阻止世界。这导致所有的Ps达到GC安全点。

 b。扫除任何未扫描的跨度。只有没有扫描的跨度
这个GC周期在预期的时间之前被迫。

 2. GC执行“标记1”子阶段。在这个分阶段，Ps是
允许本地缓存部分工作队列。

 一个。通过将gcphase设置为_GCmark来准备标记阶段
（来自_GCoff），启用写屏障，启用增变器
帮助，排队根标记工作。没有任何物体可能
扫描直到所有的Ps都启用了写屏障，这是
使用STW完成

 b。开始世界。从这一点来说，GC工作是通过标记完成的
由调度员开始的工作人员和按照执行的辅助工作
分配的一部分。写屏障遮蔽了两者
覆盖指针和任何指针的新指针值
写入（有关详细信息，请参阅mbarrier.go）。新分配的对象
立即被标记为黑色。

 C。 GC执行根标记作业。这包括扫描所有
/堆栈，着色所有全局变量，并着色任何堆指针
堆外运行时数据结构。扫描一个堆栈会停止一个
 goroutine，在栈上找到指针，然后
恢复goroutine。

 d。 GC排出灰色物体的工作队列，扫描每个灰色
对象为黑色，并在对象中找到所有指针
（这又可以将这些指针添加到工作队列中）。

一旦全局工作队列为空（但是本地工作队列缓存）
可能仍然包含工作），GC执行“标记2”子阶段。

 一个。 GC停止所有工作，禁用本地工作队列缓存，
将每个P的本地工作队列缓存刷新到全局工作队列中
缓存，并重新启用工人。

 b。 GC再次排空工作队列，如上面的2d所示。

 4.一旦工作队列为空，GC会执行标记终止。

 一个。阻止世界。

 b。将gcphase设置为_GCmarktermination，并禁用worker和
助攻

 C。从工作队列中排除剩余的工作（通常在那里）
将不会）。

 d。执行其他内务管理，例如冲洗微软。

 GC执行扫描阶段。

 一个。通过将gcphase设置为_GCoff来准备扫描阶段，
设置扫描状态并禁用写屏障。

 b。开始世界。从这点开始，新分配的对象
是白色的，如果需要，在使用之前分配扫描。

 C。 GC在后台进行并发扫描并作出响应
分配。请看下面的描述。

当分配完成后，重播序列
从上面的1开始请参阅下面的GC率的讨论。

并发扫描

扫描阶段与正常程序执行同时进行。
堆是一个跨越跨度懒惰（当一个goroutine需要另一个跨度）
并发地在后台goroutine（这有助于不受CPU限制的程序）。
在STW标记结束时，所有跨度都被标记为“需要扫描”。

后台扫除程序goroutine简单地扫描一个接一个。

为了避免请求更多的操作系统内存，而有未扫描的跨度，当一个
/ goroutine需要另一个跨度，它首先试图回收这么多的内存
通过扫描当一个goroutine需要分配一个新的小对象跨度时，
/扫描小对象跨度为相同的对象大小，直到它至少释放
一个对象当一个goroutine需要从堆中分配大对象跨度时，
/它扫描跨越，直到它至少释放堆到多个页面。有
一个这样做可能不够的情况：如果一个goroutine扫除并释放两个
不相邻的单页跨度到堆，它将分配一个新的两个

/opt/go/src/runtime/mgc.go

/opt/go/src/runtime/mgclarge.go

/opt/go/src/runtime/mgcmark.go

/opt/go/src/runtime/mgcsweep.go

/opt/go/src/runtime/mgcsweepbuf.go

/opt/go/src/runtime/mgcwork.go